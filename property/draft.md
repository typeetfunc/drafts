

Статическая проверка типа:
 ПО ПОСТРОЕНИЮ - указывает на структуру
 - на этапе компиляции, ее делает компилятор или отдельный инструмент(тайпчекер)
 - обычно довольно быстра даже для всего проекта(скалисты заплакали)
 - по умолчанию код считается не соотвествующем указаным типам 
 - тайпчекер должен увидеть доказательства в вашем коде того что значения всетаки соотвествую типам(за 
 это обычно отечают механизмы вывода типов - чем они продвинутей тем меньше надо доказывать)
 - для описания ограничений(типов) используется специальный язык(DSL), со своими ограничениями(не все можно проверить)
 - гарантия проверки 100%
TODO таблица
Динамическая проверка типа:
 - ПО РЕЗУЛЬТАТАМ - пиши как хочешь
 - на этапе исполнения и выполняется как и весь остальной код
 - написана на том же языке что и основной код
 - для верификации используем проперти тесты
 - по умолчанию считается что код удовлетворяет требованиям - не нужно что-то доказывать
 - для большого проекта проверка тестами может быть долгой
 - вероятностные гарантии(зависит от колва тестов)
 - изначально доказательство считается недоказанным и лишь если будет доказано согласованность построения всех промежуточных частей - доказательство будет считаться успешным
 - сложность доказательства зависит только от ширины доказываемого свойства - доказать что `add` возвращает число легко но доказать что `add` действительно складывает числа очень сложно 


 ПОДДЕРЖКА VS ИЗМЕНЕНИЯ

 API vs внутренняя структура
---
```typescript
import { Static } from 'runtypes'

type Family = Static<typeof FamilyWithSingleSpouse>
```
то же самое что
либо котята либо сумма - показываем что программа может делать что угодно - совсем что угодно(убивать котят стирать хард итд)
нужно понять что делает код - анализируем
как анализировать - опыт математиков
математики доказывают свои решения - используют для этого анализ как в отдельных точках так и на всей обалсти определенияgsort(sort(list)) eq sort(list)
программисты смотрят только отдельные точки
фу так делать
как проверить чтото на всей обалсти - стат анализ и генеративный тестинг
пример со сложением
есть такой подход и библиотеки для него
давайте используем ирл
пример сложный
проблема
решение 1
спеки
специ vs рефаймент
холивары про типы не нужны
решение простое
выводы
видишь типы - а они есть

