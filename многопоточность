@expfront 
вообщем имхо тут базовым понятием выступает "многозадачность", т.е возможность иметь несколько незавершенных задач одновременно(как в современных операционных системах) -  например держать два http коннекта. 
Очевидно что если у нас одно вычислительное ядро(будем рассматривать только этот случай для простоты) то мы не можем на самом деле делать 2 задачи одновременно. Значит нам надо как то время от времени переключатся между задачами(этот процесс называется переключение контекста и является частью более общего процесса который называется scheduling):
1) вариант первый - пока задача реально чето делает давайте ее не трогать, а вот если она сказала нам что заснула и ждет чегото(ответ сервера, чтения с диска итд) то давайте ее переключим на другую, а когда эта заснет или выполнится проверим не ответило ли то чего мы ждали у первой ну и если да то продолжим выполнять первую с того места откуда она нам указала при создании(обычно это задается коллбэком) и так по кругу - то есть получается такой цикл. Это и называется евент лупом. Тут важно что мы сами в коде указываем моменты когда отдаем управление и колбэки которые надо дернуть когда управление вернется.
Самый простой пример такого подхода это неблокирующий IO в линуксах и функция `select` - http://citforum.ru/programming/unix/sockets/. Epoll который использует нода на линуксе работает также. Этот подход называется кооперативная многозадачность и очевидно что у него есть проблема что если некотрая задача никогда не засыпает(считаем числа фибоначи очень долго к примеру) то остальные задачи никогда не будут выполнены. Ну и явная отдача управления в коде тоже не оч удобно - хотя можно обмазатся сахаром как угодно и в целом пофигу.
2) вариант второй - давайте сами следить за задачей и следить сколько квантов времени она выполняется и когда она начинает ожидать реакции операционной системы или если она вдруг выполняется слишком долго или ждет реакции от ос, то давайте переключатся на другую. Это вытесняющая многозадачность. Потоки и процессы(это те самые задачи) это реализация именно этого подхода. Проблема потоков и процессов только в том что их переключение слишком медленное и они много занимают в памяти. Поэтому умные люди решили что было бы круто встроить примитивы вытесняющей многозадачности непосредственно в рантайм языка и сделать их очень быстрыми. Ну то есть теже потоки только более быстрые и встроенные в язык - назвали это зелеными потоками. Каноничный пример это ерланг. 
Но эрланг это конечно хорошо но хотелось бы иметь такое и в обычных языках с обычным рантаймом. Что для этого надо? Зеленый поток выполняет некотрую функцию которая в свою очередь состоит из других функций - их вызовы складываются в некотрый стек(образуя тот самый стектрейс который мы используем для отладки). Соотвественно чтобы приостанавливать/возобновлять(для переключения) некоторую функцию надо уметь работать с ее стеком(запоминать где она остановилась, продолжать выполнение с того места где она остановилась) - очевидно что это нельзя сделать с родным стеком идущем в рантайме(он обычно написан на си и к нему нету доступа в самом языке). 
Значит надо написать свой стек которым мы сможем управлять и заменить им стандартный(такое правда не во всех языках можно сделать - в питоне пришлось сделать новый интерпретатор - staсkless python). Такие зеленые потоки которые используют функции с прохаченным стеком иногда называют fiber - волокно(то есть часть потока(по английски поток thread - нить)).
И ВНЕЗАПНО именно такой подход используется в новой архитектуре реакта для того чтобы управлять шедулингом рендринга компонентов:) "все переплетено"(с)
PS сорри за портянку просто чето давно с беком не работал - нахлынули воспоминания - захотелось выговорится :)могу гдето ошибатся, пишу по памяти)ну и в жизни все сложнее и никто не использует чистые подходы - все както комбинируют разные типы многозадачности