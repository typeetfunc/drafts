#### Стоя на плечах гигантов

Идея без которой этот подход был бы невозможен это "обмен сообщениями". Впервые эта идея появилась я языке [SmallTalk](https://ru.wikipedia.org/wiki/Smalltalk) созданным [Аланом Кэйем](https://ru.wikipedia.org/wiki/Кэй,_Алан_Кёртис). Этот язык был первым широко используемым объектно-ориентированным языком и вообще создал такую парадигму как ООП.

>Дизайн Smalltalk — и его существование вообще — обусловлен тем, что все, что мы можем описать, возможно представить рекурсивной композицией отдельных видов поведенческих строительных блоков, которые внутри самих себя скрывают свою текущую комбинацию состояния и процессов, и могут взаимодействовать друг с другом только посредством обмена сообщениями. 
>
> -- <cite>Алан Кей</cite>

То есть 2 главными столпами первого ООП языка было: композиция и обмен сообщениями. Что очень похоже на архитектуру `Cycle.js`.

Многие могут возмутится на этом моменте. Книги и статьи по ООП очень часто упоминают классы, наследование, полиморфизм, но врятли вы найдете упоминание композиции и обмена сообщениями.

>Я придумал термин «объектно-ориентированный», и вот что я вам скажу, я не имел ввиду С++. 
>
> -- <cite>Алан Кей</cite>

Дело в том, что ООП языки последовавшие за SmallTalk отказались от всех его идей: вместо композиции стало использоватся наследование, вместо обмена сообщениями вызовы методов.

Почему так произошло? Почему более общая концепция обмена сообщениями была заменена более частной концепцией вызова метода. 



#### Монады

>СТОП! Не закрывайте статью - дайте монадам шанс. Статья объясняющая что это такое человеческим языком.(TODO запах монад по утрам)
>

Монада это довольно простая и эффективная абстракция позволяющая абстрагировать control-flow в языках программирования. Например таким образом можно абстрагировать:

TODO ссылки
- проверку на `null`
- асинхронные операции
- обработку ошибок и многое другое

И самое интересное, что вы скорее всего используете монады каждый день - к примеру `Promise` это всего лишь крайне неудачно сделанная асинхронная монада, а `async-await` лишь попытка реализовать `Do-syntax` для нее.

Хорошие примеры абстракции сайд-эффектов при помощи монад:

- [`IO monad` in Haskell](https://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO)
- [`Task` in Elm](https://guide.elm-lang.org/architecture/effects/)
- [`Eff monad` in PureScript](http://www.purescript.org/learn/eff/)
- [`Task` in `redux-loop`](https://github.com/redux-loop/redux-loop)
- [`Task` in `fun-task`](https://github.com/rpominov/fun-task/blob/master/examples/io/1.js)

TODO IO is pure

#### Продолжения

Продолжение это альтернативная 

---
# Third way

 - 1967 - Simula
 - 1970 - Smalltalk - first OOP lang
  

