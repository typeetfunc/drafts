# From side-effects to manageable effects

---
# Some frontend code

Давайте посмотрим на простой пример фронтенд кода
описание работы

Что является результатом работы этой функции?

 - функция делает HTTP запрос при помощи `fetch`
 - функция устанавливает аттрибут `src` тегу `img` при помощи `.setAttribute` 

От чего зависит эта функция?

 - функция зависит от событий полученных из `document.addEventListener`
 - функция зависит от результата HTTP запроса полученного из `fetch`

Подобные неявные зависимости или результаты функции называют сайд-эффектами.

Звучит довольно просто, однако на практике в языках без явных ограничений на чистоту функции данное определение не так однозначно как кажется.

Чтобы избежать софистики давайте попробуем выделить ключевые свойства сайд-эффектов, вместо попытки дать их определение. То что будет удовлетворять этим свойствам мы и будем считать сайд-эффектом.
---
# Key properties of side-effects

Что это значит? Первоклассный объект (first-class object) это сущность в языке программирования которую:

 - можно сохранить в переменной или структурах данных
 - можно передать в функцию как аргумент
 - можно вернуть из функции как результат

Проще говоря, первоклассный объект можно легко представить в виде некоторого _значения_.
Сайд-эффекты зависят от/влияют на внешнее окружение

Это довольно очевидное свойство. Для того чтобы корректно выполнить некотрый сайд-эффект нам необходимо корректное окружение - для HTTP запроса нужна рабочая сеть, для запроса к DOM необходим сформированный DOM и так далее.

Сайд-эффекты изменяют свойства кода в котором используются - до самой вершины стека вызовов

Функция с сайд-эффектом внутри, сама становится в некотром смысле сайд-эффектом. Что такое `fetch`? Это функция которая внутри себя содержит сайд-эффекты или это целиком сайд-эффект? А если завернуть ее в дополнительную обертку? Для нас важно то что использование сайд-эффектов внутри других функций приводит к тому что эти функции приобретают все свойства сайд-эффектов.

На самом деле скорее всего это вытекает из первого свойства - но это только догадка и поэтому я решил оставить это отдельным пунктом.

Что все это значит для нас?
Код с сайд-эффектами сложен для анализа(как человеком так и машины)
Код с сайд-эффектами сложно переиспользовать
Cайд-эффекты сложно тестировать
Cайд-эффекты непредсказуемы и не воспроизводимы
Cайд-эффекты не типизируются
Усложнение интерактивной разработки кода с сайд-эффектами
Для кода с сайд-эффектами сложно применить тестирование основанное на проверке свойств
---

# Сomplexity for analysis
Для начала давайте посмотрим на код без сайд-эффектов - все функции в нем чистые.
Мы можем легко увидеть какие значения от каких зависят и от каких совсем не зависят. 
Более того, мы можем построить граф вычислений:

Это влияет на:

 - машинный анализ - IDE не сможет подсказать нам правильно ли мы используем ту или иную функцию
 - анализ человеком - зачастую код-ревью просто не работает, потому что правки кода в одном месте влияют на другую часть системы.
---
# Сomplexity for refactoring
Также в случае кода с сайд-эффектами значительно усложняется рефакторинг. К примеру удаление "неиспользующегося" кода:

К примеру мы видим что от `a` ничего не зависит и его вычисление можно смело удалить.
Мы все ещё можем сказать, что, к примеру, `b` зависит от `value`, но мы не можем со всей уверенностью утверждать, что, к примеру, `b` не зависит от вычисления `a`. Представьте, что `doSomethingA` записывает что-то в файл, из которого затем читает `doSomethingB`. Соотвественно, в коде с сайд-эффектами любое вычисление потенциально может зависеть от любого - так как все они влияют на один и тот же внешний мир.
---
# Is dead code?
Знакомая ситуация
---
# Сomplication reuse
Давай вновь взглянем на код, состоящий из чистых функций.

Мы написали функцию, которая считает длину и сумму массива.
Используя её мы можем легко написать функцию, вычисляющую только длину списка:
Или его среднее:

Чистые функции крайне легко переиспользуются - даже если они делают что-то лишнее или что-то чуть-чуть не так, мы всегда можем исправить это просто добавив обертку из еще одной чистой функции.

Давайте посмотрим на функцию с сайд-эффектами, которая делает HTTP запрос и записывает результат в некоторый файл:

Теперь где-то в коде нам понадобилось отправлять тот же запрос, но не записывать его в файл.

Cкорее всего мы добавим специальную опцию в `sendRequestAndWriteFile`:
И то же самое для ситуации когда нам захотелось отправлять запросы на другой юрл:

Так как сайд-эффект это _неявный_ результат - мы не можем повлиять на него извне места его создания - отбросить его часть или как то преобразовать, как в случае с результатом `calcLengthAndSum`.

Это заставляет нас вместо простого переиспользования добавлять множество опций в функцию, что очень сильно увеличивает [цикломатическую сложность]
Количество вариантов выполнения растет со скоростью 2^n - для функции всего с двумя булевыми опциями мы получаем уже 4 варианта исполнения, для 3 - уже 8 и так далее.
---
# 1000 and 1 flags
наверно знакомая всем ситуация когда тот или иной компонент обрастает кучей флагов на все случаи жизни
---
# Hard testing
С этим наверняка знакомы все. Сравните:

Выглядит немного сложнее, да? 
Но это только пол беды

Зачем мы вообще пишем автоматизированные тесты? Для того, чтобы контролировать _изменения_ кодовой базы - в случае изменения поведения кода мы сразу увидим, что старые тесты не пройдут. Дело в том, что при достаточно большой кодовой базе различные изменения могут конфликтовать друг с другом и «ломать» друг друга. Автоматические тесты защищают наши изменения от случайной поломки при каких-либо правках (это может быть банальный мерж конфликтов).

Давайте изменим тестируемые функции и посмотрим, что произойдет в обоих случаях.
---
# Broken testing
Тест, конечно же, упадет - `4` не равно `{result: 4}`.

Теперь давайте изменим `remoteAdd`:
Результат работы функции изменился - теперь она еще шлет евент для логгинга. Однако наш тест совершенно этого не заметил и продолжает проходить как ни в чем не бывало.
---
# Some doubts
собственно тесты теряют свой изначальный смысл - правка может легко остатся незамеченной
давайте разбиратся что мы можем сделать
---
# Solution: explicit dependencies
мы можем принять соглашение что все зависимости которые могут исполнять сайд-эффекты должны явно передаватся в функцию, то есть


Наш тест упадет с `undefined is not function`, так как мы не передали `writeFile`. Отлично!
Этот подход лежит в основе и является причиной появления такой концепции как  внедрения зависимостей(DI) которая является ключевой во многих фреймворках - например ангуляре, вью(Да и в томже реакте - просто там она не так явно задана)

А есть ли какие проблемы у подобного подхода?
---
# DI is the opium of the developers
На картинке не зря изображен шприц - ди это по большому счету обезболивающее которое да снимает часть боли вызванной проблемой сайд-эффектов но не устраняет причин - опиум для разработчиков
Во первых она создает часть проблем сама
 - мы не можем точно определить, какие зависимости делают сайд-эффект, а какие нет. Поэтому мы будем передавать абсолютно _все_ зависимости так. Очевидно, что делать это самостоятельно невозможно, поэтому нам понадобится специальная система модулей - а это может быть довольно тяжеловестно и неудобно

Во вторых она не решает проблем целиком
даже с такой системой мы все ещё можем написать плохой мок в тестах - к примеру полениться проверить вызов метода `.put` у `HttpClient`. Да, мы сделали описание зависимости от внешнего мира более явным. Но у нас всё ещё нет стандартного способа сравнить состояния мира до и после - как мы можем сделать это с данными при помощи стандартной операции глубокого сравнения. 
 - «построить мир» не такое уж и простое занятие - точно возпроизвести состояние всех зависимостей может быть очень не просто. Оссобенно когда необходимо смоделировать ситуацию меняющегося во время теста «мира» - например, в тестируемой функции есть несколько чтений и записей файла, которые влияют на результаты друг друга.
---
# Unpredictability and irreproducible
Станете ли вы заворачивать вызов `add(2, 2)` в блок `try/catch`? Думаю нет - в этом нет смысла.
А `divide(a, b)`? Да, конечно - при `b === 0` произойдет ошибка.

Может ли произойти ошибка при вызове `remoteAdd(2, 2)` и если да, то при каких входных параметрах? Да, может, при любых параметрах. А может и не произойти. Мы не знаем, и никак не можем повлиять на это. Внешний мир непредсказуем, он может сломаться в любой момент - браузер может упасть, сеть может погаснуть, а сервер сгореть.

Из-за того, что внешний мир непредсказуем и постоянно изменяется, мы также не можем воспроизвести результаты вычислений, содержащих сайд-эффекты.

`add(a, b) === add(a, b)` будет всегда истинно в любых условиях и окружении. Мы можем легко воспроизвести результаты некоторой проблемы с продакшена, просто взяв, к примеру, входные данные с мониторинга и запустив вычисления с этими параметрами. Сайд-эффекты приводят к невоспроизводимым багам - чтобы понять в чём была проблема, нам надо проанализировать не только наш код, но и состояние всего окружающего мира в тот момент. Это намного более трудоёмко, а порой и вообще невозможно.
---
# Inability to typify

Одним из способов контроля кодовой базы и доказательства отсутствия нежелательного поведения программы является статическая типизация.

Очень много копьев сломано вокруг того нужна ли она вообще

Моё мнение простое, статическая типизация это инструмент незаменимый для написания некоторого типа ПО - такого, где очень много кода, много программистов, много связанных подсистем.

Однако вопрос не в этом, а в том, как на использование типизации влияют сайд-эффекты. 
---
# Inability to typify
Рассмотрим пример - предположим мы имеем функцию, которая по описанию изменения как-то модифицирует `DOM`: 

```javascript
function patchDOM(patch: DOMPatch): void { ... }
``` 

Неявно эта функция зависит от существования `DOM`. И её результатом является его изменение. Однако мы никак не можем описать эту информацию в типах - ни о неявной зависимости от `DOM`, ни о том, что её результатом будет его изменение. В результате, если мы случайно применим эту функцию в окружении без DOM, то получим ошибку при исполнении:

```javascript
function serverProgram() {
  ...
  patchDOM(patch); // run-time error
}
```

Сайд-эффекты за счет своей неявности не поддаются описанию типами и тайп-чекер не может помочь найти проблемы с ними.


---
# Solution?
Возможным решением является использование имитации Higher-Kinded types для реализации типа `Eff` при помощи `Flow`.

И соотвественно `serverProgram` просто не скомпилируется если у нее в типе не будет указан `Eff` типа `{ write: DOM }`, а внутри нее будет использоватся `patchDOM`.

Однако, такой способ:

 - полагается на не самые очевидные механизмы `Flow` и довольно не прост для понимания.
 - такие типы не будут выведены для javascript API (`console`, `XMLHttpRequest` и так далее)
 - не поможет в случае сайд-эффектов в коллбэках или других местах из которых нельзя _вернуть_ результат

В общем, решение не общее и довольно сложное.
---
# Impossibility of an interactive development

Интерактивная разработка начинает набирать популярность. Практически все более-менее популярные языки имеют в стандартной поставке REPL(отдельно или в составе дебаггера). Современные браузеры и вообще позволяют писать код прямо в них.

Появляются и отдельные IDE нацеленные именно на интерактивную разработку. К примеру Light table, позволяющая в реальном времени следить за результатами вычислений:

Отличная статья о том почему интерактивная разработка - это прекрасно!

---
# Problems


Давайте посмотрим какие коррективы вносят сайд-эффекты в подобную практику. Допустим мы разрабатываем функцию осуществляющую запрос на удаление некотрого юзера - `deleteUser`. Очевидно что мы не сможем запустить эту функцию несколько раз для одного и того же юзера, чтобы проверить ее работу в REPL. Более того для проверки результатов ее работы нам понадобится каждый раз смотреть текущее состояния сервера.

Главное преимущество интерактивной разработки - быстрая ответная реакция от только что написанного кода - в таком случае сводится на нет, тем что нам необходимо постоянно наблюдать состояние окружающего мира и периодически "фиксить" его. Например востанавливать удаленного юзера.

Возможным решением здесь будет REPL интегрированный в тестовый фреймворк - `jest-repl`, `mocha debug repl` с встроенной возможностью устанавливать моки для определенных сайд-эффектов.
---
# Complexity in providing certain properties of program

Тестирование основанное на проверке свойств или генеративное тестирование или property-based тестирование - техника позволяющая описывать свойства какой-то программной сущности(функции к примеру) и проверять ее при помощи генерации входных параметров.

Это очень мощная техника, которая позволяет доказать(с некотрой долей вероятности конечно же) некотрые утверждения о программном коде. Она становится особенно важной в языках без сильной статической системы типов. 

Но крайне сложно определить какое либо свойство для кода с сайд-эффектами - за счет их непредсказуемости.
---
# перерыв

Сайд-эффекты как гремлины ломают все доступные программисту инструменты до которых доберутся: типизация, тесты, интерактивные среды, статические анализаторы в IDE, код-ревью.

Но почему это все действительно важно? Ну да что-то стало сложнее сделать - но программисты привыкли борьбе со сложностью. И в отдельных пунктах я приводил результаты такой борьбы - инструменты которые призваны хоть как-то уменьшить негативное влияние сайд-эффектов.

Проблема в том что сайд-эффекты не только усложняют написание и работу с самим кодом, но и "ломают" два _базовых_ способа разработки ПО. И это уже реальная проблема.
---
# Two kinds of programming
На самом _высоком_ уровне по большому счету существует только два способа разработки. Все остальное либо их комбинации, либо производные.

Давайте расмотрим на простом примере оба способа. Предположим что нам надо разработать систему `printSum`, которая будет выводить на экран сумму какого то списка.
---
# Top-Down
 Определяем спецификацию самого верхнего уровня API - описываем входное и выходное воздействие 

```javascript
printSum(list: Array): PrintedSumToScreenEffect
```
 - Затем определяем спецификации API уровнем ниже которые необходимы чтобы из `Array` получить `PrintedSumToScreenEffect`. Очевидно что нам необходимы две функции.

```javascript
sum(list: Array): number
printToScreen(value: number): PrintedSumToScreenEffect
```

Теперь просто глядя на спецификации мы понимаем что сначала необходимо вызывать от `list` функцию `sum`, а затем от ее результата `printToScreen`.

Теперь осталось придумать как записывать спецификацию для описания входных и выходных данных, в идеале она должна:

 - описывать все возможные входные воздействия и результаты и довольно общим образом - тесты подходят не очень хорошо, так как они описывают отдельные кейсы(точки вместо общего поведения системы).
 - мы должны иметь возможность проверить, что разработанная нами программа соответствует изначальной спецификации - иначе при имплементации, есть большой шанс получить большое расхождение со спецификацией. Диаграммы и прочие способы связанные с ИЗО не дадут нам такой возможности

 Вы наверно уже догадались что лучше все здесь подойдет хорошая система типов
---
# Bottom-Up
Мы можем пойти с другой стороны:

 - Уже по описанию задачи видно что нам надо будет уметь выводить чтото на экран и надо уметь складывать. Мы не будем пытаться определить точные спецификации. Вместо этого просто напишем общие и минимально необходимые функции для этого. Больше всего эти функции будут похожи на отдельные небольшие библиотеки - очень малоспецифичные и очень переиспользуемые единицы. Так как мы еще не знаем что за API нам придется с их помощью строить.

 - Затем строим из этих функций API более высокого уровня.


Для такого итеративного процесса нам необходим инструмент:

 - позволяющий легко экспериментировать с небольшими кусочками кода и иметь возможность быстро запустить отдельные функции на разных входных данных
 - при этом в процессе разработки, нам не так важно зафиксировать некотрый результат и уметь его воспроизводить - скорее всего мы редко будем менять имплементацию уже написанного API. Тесты тут будут скорее мешать низкой скоростью ответной реакции, и своей хрупкостью

Лучше всего для такого стиля разработки подойдет `REPL`. Собственно такой вид разработки и получил распространие в языках с богатой практикой использования `REPL` - `Lisp`, `SmallTalk`.
---
# Two way...
итого у нас есть два способа разработки
сверху вниз и для него мы можем использовать спецификацию при помощи типов

и снизу вверх и для него основным способ разработки является репл
---
# Or no way?

 Однако как мы выяснили без определенных уловок, большая часть систем типов не способны работать с сайд-эффектами и уж точно не могут вывести типы таких эффектов из контекста. Можно конечно было бы заменить типы тестами(что например сделано во всем известном Test Driven Development) - однако как мы уже увидели тесты не очень хорошо для этого подходят из-за своей дискретной природы, и к тому же они тоже страдают от сайд-эффектов.
 
 Таким образом сайд-эффекты ломают первый базовый способ разработки ПО. а со что со вторым?
как мы помним `REPL` теряет свое главное приемущество(быстрый отклик), при разработке кода с сайд-эффектами. Второй фундаментальный способ тоже не выдержал битвы с сайд-эффектами.

Но ведь не весь наш код содержит сайд-эффекты? И может все эти неприятности касаются только тех участков в которых мы их используем? Можно просто старатся использовать поменьше "грязных" функций и побольше "чистых"?
---
# Infects side-effects free code

давайте расмотрим вот такую структуру кода - тут все функции чистые
а теперь давайте сделаем одну из них грязной - добавив кеширование в локалсторадж
и вуаля - все все функции выше тоже стали грязными
Изменив код всего _одной_ функции - мы изменили свойства(в плане тестируемости, надежности, композируемости) для _всего_ стека вызовов.

В некотром смысле мы теряем _контроль_ над своим кодом. Мы не можем гарантировать что никакие свойства для своего кода - так как API на котором основан наш код может _внезапно_ изменить свои свойства и "заразить" наш код.
---
# Two-color language
Программисты заставшие `JS` без `Promise` и `async-await` могут почувствовать, что-то знакомое в описании недостатков сайд-эффектов. Эти же проблемы зачастую упоминались в обсуждении асинхронных функций основанных на коллбэках.

> Асинхронность и сайд-эффекты выглядят довольно связанными проблемами - решив только одну из них вы не избавитесь от всех их недостатков. И наоброт - хорошее решение одной из них может помочь решить другую. В дальнейшем мы увидим что это не случайно и на самом деле эти проблемы являются лишь частными случаями более фундаментальной проблемы отсутсвия общего способа абстракции control-flow программы и выражение его first-class значениями.

Но самое ужасное в таких функциях было то, что они заражали весь код, в котором они использовались. Обычная функция при использования в ней функции с коллбэком переставала возвращать результат через `return` и начинала прокидывать его в коллбэк - и в свою очередь сама становилась "ядом" для использующего ее кода.

Появилась даже метафора двух-цветного языка:
все функции в языке делятся на "красные" и "синие". И чтобы вызвать "красную" функцию в "синей" нам необходимо перекрасить "синюю" функцию в красный цвет.

Происходило это из-за того что подобные асинхронные функции для взаимодействия с кодом не использовали стандартные способы взаимодействия - возврат значения через `return`. Как мы помним сайд-эффекты также возвращают результаты не через `return`, а своим способом(не явно).

Поэтому все тоже самое применимо и к ним:

> Функция с сайд-эффектом внутри, сама становится сайд-эффектом. Следовательно используя такую функцию внутри другой(чистой) мы автоматически преврашаем ее в грязную - она начинает возвращать часть результата неявно. И так далее до самой вершины стека вызовов.
---
# Ice-9 for source code
.center-text[
  <img alt="Cats cradle" src="./img/cats-cradle.jpg" width="50%"/>
]
> \- Ты читал "Колыбель для кошки"?
>
> \- Нет
>
> \- Итак, этом романе мир погибает потому, что во льду обнаружена молекула, которая, при соприкосновении с водой, превращает ее в лед. А поскольку все воды мира связаны - пруд с ручьем, ручей с рекой, река с озером, озеро с океаном - таким образом весь мир замерзает и погибает. И эта молекула называется - "Лед-9"
>
---
# перерыв
---
# Two type of calc

и так мы ввыяснили что в нашем коде есть два типа вычислений - чистые(просто вычисления) и грязные(будем называть их исполнения)

Однако в типичном коде они перемешаны и неотделены друг от друга - давайте отделим
пусть все функции будут возвращать лишь описания эффектов - некотрую структуру данных которая содержит всю необходимую информмацию для выполнения эффекта
а выполнять мы их будем вне функции - теперь мы видим эти два типы кода явно
---
# Pure vs Effectful
.left-column-50[
Pure:
```javascript
var res1 = doSmth1(start);
var res2 = doSmth2(res1);
var res3 = doSmth3(res2);
```
<img src="./img/cf-diagram-sync.svg" />
]
.right-column-50[
With effects:
```javascript
var eff1 = doSmth1(start);
var res1 = runEffect(eff1);
var eff2 = doSmth2(res1);
var res2 = runEffect(eff2);
var eff3 = doSmth3(res2);
var res3 = runEffect(eff3);
```
<img src="./img/cf-diagram-effect.svg" />
]
---
# Sync vs Async
.left-column-50[
Sync:
```javascript
var res1 = doSmth1(start);
var res2 = doSmth2(res1);
var res3 = doSmth3(res2);
```
<img src="./img/cf-diagram-sync.svg" />
]
.right-column-50[
Async:
```javascript
doSmth1(res1 => {
    doSmth2(res1, res2 => {
        doSmth3(res2);
    });
});
```
<img src="./img/cf-diagram-async.svg" />
]
---
# Safe vs Error handling
.left-column-50[
Without error:
```javascript
var res1 = doSmth1(start);
var res2 = doSmth2(res1);
var res3 = doSmth3(res2);
```
<img src="./img/cf-diagram-sync.svg" />
]
.right-column-50[
With error handling:
```javascript
var res1 = doSmth1(start);
if (isError(res1)) {
    var res2 = doSmth2(res1);
    if (isError(res2)) {
        var res3 = doSmth2(res2);
    } else { handle(res2) }
} else { handle(res3) }
```
<img src="./img/cf-diagram-error.svg" />
]
---
# Not nullable vs nullable
.left-column-50[
Not nullable:
```javascript
var res1 = doSmth1(start);
var res2 = doSmth2(res1);
var res3 = doSmth3(res2);
```
<img src="./img/cf-diagram-sync.svg" />
]
.right-column-50[
With null-check:
```javascript
var res1 = doSmth1(start);
if (!isNull(res1)) {
    var res2 = doSmth2(res1);
    if (!isNull(res2)) {
        var res3 = doSmth2(res2);
    }
}
```
<img src="./img/cf-diagram-null.svg" />
]
---
# Control-flow

> In computer science, control flow (or flow of control) is the order in which individual statements, instructions or function calls of an imperative program are executed or evaluated.
>
> -- <cite>Wiki</cite>

Example control-flow primitive:
- `if`
- `switch ... case`
- `while`, `for`
- `{ some code }`
- `break`, `continue`
- `throw new Error`
- `return res`, `yield res`
---
# GOTO
.center-text[
<img src="./img/goto.jpg" width="65%"/>
<img src="./img/goto_example.gif"/>
]
---
# Example: error handling
.left-column-50[
Today:
```javascript
var res1 = doSmth1(start);
if (isError(res1)) {
    var res2 = doSmth2(res1);
    if (isError(res2)) {
        var res3 = doSmth2(res2);
    } else { handle(res2) }
} else { handle(res3) }
```
]
.right-column-50[
With GOTO:
```javascript
error:
  handle(errorMsg)

global errorMsg;
function exitIfErr(res) {
    if (isError(res) {
        errorMsg = res;
        goto error;
    } else {
        return res;
    }
}
// calculation
var res1 = exitIfErr(doSmth1(start));
var res2 = exitIfErr(doSmth2(res1));
var res3 = exitIfErr(doSmth3(res1));
```
]
---
# Don't forget where you came from
Mother of all statement:
.center-text[
  `if value then goto label`
]
.left-column-50[
```c
i = 1;
while(i < 4) {
  print(i);
  i = i + 1;
}
```
]
.right-column-50[
```c
i = 1
START: if i = 4 then goto END
  print(i)
  i = i + 1
  goto START
```
]
.center-text[
<img src="./img/machine-turing.png" width="85%" />
]
---
# All is need you is...
.left-column-50[
Calculation:

`c = add(inc(a), dec(b))`

Order execution:

1) `inc(a)`, `dec(b)`

2) `add(inc(a), dec(b))`

<img src="./img/strict.svg" />
]
.right-column-50[
Conditional jump:

`if add(a, b) then goto LABEL`

Order execution:

1) `add(a, b)`

2) `if (add(a, b))`

3) `goto label`

<img src="./img/if-order.svg" />
]
---
# New World Order
Imagine some calculation with reverse order calculation
.center-text[
`c = add(inc(a), dec(b))`
]

1) `add(placeholder1, placeholder2)`

2) `inc(a)`

3) `dec(b)`
.center-text[
<img src="./img/lazy.svg" />

`if(a, goto label)`
]
1) `if(placeholder1, placeholder2)`

2) `a`

3) maybe `goto label`
---
# In your code

.left-column-50[
```javascript
var x = {}
x && x.obj && x.obj.prop
```
<img src="./img/lazy-example.svg" />
]
.right-column-50[
```javascript
var x = {}
and(and(x, x.obj), x.obj.prop)
```
<img src="./img/strict-example.svg" />
]
---
# Lazy effects

```javascript
requestUser()
{isEff: true, type: "http", url: "/user", payload: {id: 2}}

writeToFile("Ivan")
{isEff: true, type: "file", name: "./sys.log", data: "Ivan" }
```
.left-column-50[
```javascript
writeToFile(requestUser().fio)
```
```javascript
{
  calc: writeToFile,
  args: [
    {
      calc: x => x.fio,
      args: {
        calc: requestUser
      }
    }
  ]
}
```
]
.right-column-50[
<img src="./img/effects-lazy.svg" /> 
]
---
# This is the norm
Normal order a.k.a call-by-name(call-by-need) a.k.a lazy evaluation

Without it all our languages is not turing-complete

Theorem: all calculations can be calculated with normal order

First "programming language":

- 1936 Alonzo Church - Lambda calculus - normal order
- 1936 Alan Turing - Turing machine - applicative order

First computer:
- 1944 - Von Neumann architecture(inspired Turing machine)

.right-column-50[
With normal order:

**all is calculation**
]
.left-column-50[
With applicative order:

**all is calculation+control-flow**
]
---
# Control-flow as contituation
Continuation-passing style:

Effects:
```javascript
requestUser(user => {
  writeToFile(user.fio,
    res => { ... }
  )
})
```

Errors:
```javascript
doWithErrors(res => {
  doWithErrors2(
    res,
    res2 => { ... },
    handleErr
  )
},handleErr)
```
---
# Introduce call/cc
.left-column-50[
```javascript
var a = 3;
var b = a
var c = b + 1 // 4
```
]
.right-column-50[
```javascript
var a = 3;
var b = callcc(cont => {
  cont(a)  
});
var c = b + 1 // 4
```
```javascript
var r;
var a = 3;
var b = callcc(cont => {
  r = cont;  
});
var c = b + 1
r(a) // 4
```
]
---
# Exceptions
```javascript
var cont;
function throw (err) {
  cont(err);
}
function try(program, handleErr) {
  var res = callcc(c => {
    cont = c;
    program()
  })
  handleErr(res)
}

try(
  () => {
    var a = doWithErrors() // throw new Error()
    ...
  },
  err => { ... }
)
```
[Writing exceptions by contituations](http://courses.cs.washington.edu/courses/cse341/04wi/lectures/15-scheme-continuations.html)
---
# Algebraic effects
```javascript
var cont;
function perform (effect) {
  callcc(currCont => {
    var res = cont(err);
    currCont(res)  
  })  
}
function run(program, handleEffect) {
  var res = callcc(c => {
    cont = c;
    program()
  })
  return handleEffect(res)
}

run(
  () => {
    var user = perform(requestUser())
    var fio = user.fio
    var res = perform(writeToFile(fio))
  },
  eff => runEffect(eff)
)
```
[Algebraic effects: esdiscuss](https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers)
---
# Continuation as precursor

- exceptions
- algebraic effects with handlers
- generators
- fibers
- coroutines
---
# Control-flow as High Order Calculation
```javascript
writeToFile(requestUser().fio)
```
Control-flow is a glue for calculations

From execution to calculation a.k.a thunk:

`requestUser() -> () => requestUser()`

Thunk is lazy!

.left-column-50[
```javascript
// calculation
var ioAction = withEffects(
  () => requestUser(),
  x => x.fio,
  fio => writeToFile(fio)
)

// execution
run(ioAction)
```
]
.right-column-50[
```javascript
ioAction = {
  calc: fio => writeToFile(fio),
  args: [
    {
      calc: x => x.fio,
      args: {
        calc: () => requestUser()
      }
    }
  ]
}
```
]
---
# Lets make great interface
.left-column-50[
```javascript
function IO(fn) {
  this = {
    calc: fn,
    args: []
  };
}
IO.prototype.then = fn => {
  this = {
    calc: fn,
    args: [
      this
    ]
  }
}
```
]
.right-column-50[
```javascript
var ioAction = new IO(requestUser)
  .then(x => x.fio)
  .then(fio =>
    new IO(() => writeToFile(fio))
  )

run(ioAction)
```
```javascript
ioAction = {
  calc: new IO(() => writeToFile(fio)),
  args: [
    {
      calc: x => x.fio,
      args: {
        calc: new IO(requestUser)
      }
    }
  ]
}
```
]
---
# Not only effects...
```javascript
var x = {}
x && x.obj && x.obj.prop
```

.left-column-50[
```javascript
function Option(value) {
  this = value;
}
Option.prototype.then = fn => {
  this = isNil(this) ?
    this :
    fn(this)
}
```
]

.right-column-50[
```javascript
var x = {};
var val = new Option(x)
  .then(val => val.obj)
  .then(obj => val.obj.prop)
```
]
---
# Representing monads

 - `of`, `pure`, `unit` - constructor. *How wrap value to monad?*
 - `flatMap`, `bind`, `return` - applyer. *How unwrap value from monad?*

Monad laws:
 - Left identity: `flatMap(f, of(x)) === f(x)`
 - Right identity: `flatMap(of, x)`
 - Associativity: `flatMap(g, flatMap(f, x)) === flatMap(x => g(f(x)), x)`

[Dont break laws!](https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/)

**Beware of Haskell Police!**

---
# Monads everywhere!

- `Promise` a.k.a `Task` a.k.a `Future`
- `Optional` a.k.a `Option` a.k.a `Maybe`
- `List`
- `Either` a.k.a `Try` a.k.a `Error`
- `Observable`
---
# Two way?

Monads and Contituations is isomorphic and equal by power

[Representing Monads](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8213&rep=rep1&type=pdf)

This is just representations of **control-flow**

Control-flow is originated by incompleteness strict(applicative) evaluation

[Lazy Evaluation and Delimited Control](http://www.osl.iu.edu/publications/prints/2009/garcia09popl-lazy.pdf)
---
# A journey of a thousand miles starts with a single step
![Scheme of all](./img/origins.svg)
---
# Plato's cave

<img alt="Plato cave" src="./img/platoCave.jpg" width="100%" />
---
# Third way???

Message passing as foundation of OOP:
 - 1967 - [Simula](https://en.wikipedia.org/wiki/Simula)
 - 1970 - [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk)

Message passing as foundation concurrent computation:
 - 1973 - [Actor model](https://en.wikipedia.org/wiki/Actor_model)
 - 1977 - [Communicating sequential processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes)

All modern frontend framework based on message-passing primitive:
 - `store` in `flux`, `redux`, `ngrx/store`
 - `computed` in `mobx`, `vue`, `ember`
 - `EventEmitter` in angular2
 - `subscriptions` and `Cmd` in Elm

All modern backend framework based on message-passing primitive:
 - `actor` in `Akka`, `Erlang`, `Elixir`
 - `channels` in Go
 - `ReactiveStreams` in Spring