# From side-effects to manageable effects

---
# Some frontend code

Давайте посмотрим на простой пример фронтенд кода
описание работы

Что является результатом работы этой функции?

 - функция делает HTTP запрос при помощи `fetch`
 - функция устанавливает аттрибут `src` тегу `img` при помощи `.setAttribute` 

От чего зависит эта функция?

 - функция зависит от событий полученных из `document.addEventListener`
 - функция зависит от результата HTTP запроса полученного из `fetch`

Подобные неявные зависимости или результаты функции называют сайд-эффектами.

Звучит довольно просто, однако на практике в языках без явных ограничений на чистоту функции данное определение не так однозначно как кажется.

Чтобы избежать софистики давайте попробуем выделить ключевые свойства сайд-эффектов, вместо попытки дать их определение. То что будет удовлетворять этим свойствам мы и будем считать сайд-эффектом.
---
# Key properties of side-effects

Что это значит? Первоклассный объект (first-class object) это сущность в языке программирования которую:

 - можно сохранить в переменной или структурах данных
 - можно передать в функцию как аргумент
 - можно вернуть из функции как результат

Проще говоря, первоклассный объект можно легко представить в виде некоторого _значения_.
Сайд-эффекты зависят от/влияют на внешнее окружение

Это довольно очевидное свойство. Для того чтобы корректно выполнить некотрый сайд-эффект нам необходимо корректное окружение - для HTTP запроса нужна рабочая сеть, для запроса к DOM необходим сформированный DOM и так далее.

Сайд-эффекты изменяют свойства кода в котором используются - до самой вершины стека вызовов

Функция с сайд-эффектом внутри, сама становится в некотром смысле сайд-эффектом. Что такое `fetch`? Это функция которая внутри себя содержит сайд-эффекты или это целиком сайд-эффект? А если завернуть ее в дополнительную обертку? Для нас важно то что использование сайд-эффектов внутри других функций приводит к тому что эти функции приобретают все свойства сайд-эффектов.

На самом деле скорее всего это вытекает из первого свойства - но это только догадка и поэтому я решил оставить это отдельным пунктом.

Что все это значит для нас?
Код с сайд-эффектами сложен для анализа(как человеком так и машины)
Код с сайд-эффектами сложно переиспользовать
Cайд-эффекты сложно тестировать
Cайд-эффекты непредсказуемы и не воспроизводимы
Cайд-эффекты не типизируются
Усложнение интерактивной разработки кода с сайд-эффектами
Для кода с сайд-эффектами сложно применить тестирование основанное на проверке свойств
---

# Сomplexity for analysis
Для начала давайте посмотрим на код без сайд-эффектов - все функции в нем чистые.
Мы можем легко увидеть какие значения от каких зависят и от каких совсем не зависят. 
Более того, мы можем построить граф вычислений:

Это влияет на:

 - машинный анализ - IDE не сможет подсказать нам правильно ли мы используем ту или иную функцию
 - анализ человеком - зачастую код-ревью просто не работает, потому что правки кода в одном месте влияют на другую часть системы.
---
# Сomplexity for refactoring
Также в случае кода с сайд-эффектами значительно усложняется рефакторинг. К примеру удаление "неиспользующегося" кода:

К примеру мы видим что от `a` ничего не зависит и его вычисление можно смело удалить.
Мы все ещё можем сказать, что, к примеру, `b` зависит от `value`, но мы не можем со всей уверенностью утверждать, что, к примеру, `b` не зависит от вычисления `a`. Представьте, что `doSomethingA` записывает что-то в файл, из которого затем читает `doSomethingB`. Соотвественно, в коде с сайд-эффектами любое вычисление потенциально может зависеть от любого - так как все они влияют на один и тот же внешний мир.
---
# Is dead code?
Знакомая ситуация
---
# Сomplication reuse
Давай вновь взглянем на код, состоящий из чистых функций.

Мы написали функцию, которая считает длину и сумму массива.
Используя её мы можем легко написать функцию, вычисляющую только длину списка:
Или его среднее:

Чистые функции крайне легко переиспользуются - даже если они делают что-то лишнее или что-то чуть-чуть не так, мы всегда можем исправить это просто добавив обертку из еще одной чистой функции.

Давайте посмотрим на функцию с сайд-эффектами, которая делает HTTP запрос и записывает результат в некоторый файл:

Теперь где-то в коде нам понадобилось отправлять тот же запрос, но не записывать его в файл.

Cкорее всего мы добавим специальную опцию в `sendRequestAndWriteFile`:
И то же самое для ситуации когда нам захотелось отправлять запросы на другой юрл:

Так как сайд-эффект это _неявный_ результат - мы не можем повлиять на него извне места его создания - отбросить его часть или как то преобразовать, как в случае с результатом `calcLengthAndSum`.

Это заставляет нас вместо простого переиспользования добавлять множество опций в функцию, что очень сильно увеличивает [цикломатическую сложность]
Количество вариантов выполнения растет со скоростью 2^n - для функции всего с двумя булевыми опциями мы получаем уже 4 варианта исполнения, для 3 - уже 8 и так далее.
---
# 1000 and 1 flags
наверно знакомая всем ситуация когда тот или иной компонент обрастает кучей флагов на все случаи жизни
---
# Hard testing
С этим наверняка знакомы все. Сравните:

Выглядит немного сложнее, да? 
Но это только пол беды

Зачем мы вообще пишем автоматизированные тесты? Для того, чтобы контролировать _изменения_ кодовой базы - в случае изменения поведения кода мы сразу увидим, что старые тесты не пройдут. Дело в том, что при достаточно большой кодовой базе различные изменения могут конфликтовать друг с другом и «ломать» друг друга. Автоматические тесты защищают наши изменения от случайной поломки при каких-либо правках (это может быть банальный мерж конфликтов).

Давайте изменим тестируемые функции и посмотрим, что произойдет в обоих случаях.
---
# Broken testing
Тест, конечно же, упадет - `4` не равно `{result: 4}`.

Теперь давайте изменим `remoteAdd`:
Результат работы функции изменился - теперь она еще шлет евент для логгинга. Однако наш тест совершенно этого не заметил и продолжает проходить как ни в чем не бывало.
---
# Some doubts
собственно тесты теряют свой изначальный смысл - правка может легко остатся незамеченной
давайте разбиратся что мы можем сделать
---
# Solution: explicit dependencies
мы можем принять соглашение что все зависимости которые могут исполнять сайд-эффекты должны явно передаватся в функцию, то есть


Наш тест упадет с `undefined is not function`, так как мы не передали `writeFile`. Отлично!
Этот подход лежит в основе и является причиной появления такой концепции как  внедрения зависимостей(DI) которая является ключевой во многих фреймворках - например ангуляре, вью(Да и в томже реакте - просто там она не так явно задана)

А есть ли какие проблемы у подобного подхода?
---
# DI is the opium of the developers
На картинке не зря изображен шприц - ди это по большому счету обезболивающее которое да снимает часть боли вызванной проблемой сайд-эффектов но не устраняет причин - опиум для разработчиков
Во первых она создает часть проблем сама
 - мы не можем точно определить, какие зависимости делают сайд-эффект, а какие нет. Поэтому мы будем передавать абсолютно _все_ зависимости так. Очевидно, что делать это самостоятельно невозможно, поэтому нам понадобится специальная система модулей - а это может быть довольно тяжеловестно и неудобно

Во вторых она не решает проблем целиком
даже с такой системой мы все ещё можем написать плохой мок в тестах - к примеру полениться проверить вызов метода `.put` у `HttpClient`. Да, мы сделали описание зависимости от внешнего мира более явным. Но у нас всё ещё нет стандартного способа сравнить состояния мира до и после - как мы можем сделать это с данными при помощи стандартной операции глубокого сравнения. 
 - «построить мир» не такое уж и простое занятие - точно возпроизвести состояние всех зависимостей может быть очень не просто. Оссобенно когда необходимо смоделировать ситуацию меняющегося во время теста «мира» - например, в тестируемой функции есть несколько чтений и записей файла, которые влияют на результаты друг друга.
---
# Unpredictability and irreproducible
Станете ли вы заворачивать вызов `add(2, 2)` в блок `try/catch`? Думаю нет - в этом нет смысла.
А `divide(a, b)`? Да, конечно - при `b === 0` произойдет ошибка.

Может ли произойти ошибка при вызове `remoteAdd(2, 2)` и если да, то при каких входных параметрах? Да, может, при любых параметрах. А может и не произойти. Мы не знаем, и никак не можем повлиять на это. Внешний мир непредсказуем, он может сломаться в любой момент - браузер может упасть, сеть может погаснуть, а сервер сгореть.

Из-за того, что внешний мир непредсказуем и постоянно изменяется, мы также не можем воспроизвести результаты вычислений, содержащих сайд-эффекты.

`add(a, b) === add(a, b)` будет всегда истинно в любых условиях и окружении. Мы можем легко воспроизвести результаты некоторой проблемы с продакшена, просто взяв, к примеру, входные данные с мониторинга и запустив вычисления с этими параметрами. Сайд-эффекты приводят к невоспроизводимым багам - чтобы понять в чём была проблема, нам надо проанализировать не только наш код, но и состояние всего окружающего мира в тот момент. Это намного более трудоёмко, а порой и вообще невозможно.
---
# Inability to typify

Одним из способов контроля кодовой базы и доказательства отсутствия нежелательного поведения программы является статическая типизация.

Очень много копьев сломано вокруг того нужна ли она вообще

Моё мнение простое, статическая типизация это инструмент незаменимый для написания некоторого типа ПО - такого, где очень много кода, много программистов, много связанных подсистем.

Однако вопрос не в этом, а в том, как на использование типизации влияют сайд-эффекты. 
---
# Inability to typify
Рассмотрим пример - предположим мы имеем функцию, которая по описанию изменения как-то модифицирует `DOM`: 

```javascript
function patchDOM(patch: DOMPatch): void { ... }
``` 

Неявно эта функция зависит от существования `DOM`. И её результатом является его изменение. Однако мы никак не можем описать эту информацию в типах - ни о неявной зависимости от `DOM`, ни о том, что её результатом будет его изменение. В результате, если мы случайно применим эту функцию в окружении без DOM, то получим ошибку при исполнении:

```javascript
function serverProgram() {
  ...
  patchDOM(patch); // run-time error
}
```

Сайд-эффекты за счет своей неявности не поддаются описанию типами и тайп-чекер не может помочь найти проблемы с ними.


---
# Solution?
Возможным решением является использование имитации Higher-Kinded types для реализации типа `Eff` при помощи `Flow`.

И соотвественно `serverProgram` просто не скомпилируется если у нее в типе не будет указан `Eff` типа `{ write: DOM }`, а внутри нее будет использоватся `patchDOM`.

Однако, такой способ:

 - полагается на не самые очевидные механизмы `Flow` и довольно не прост для понимания.
 - такие типы не будут выведены для javascript API (`console`, `XMLHttpRequest` и так далее)
 - не поможет в случае сайд-эффектов в коллбэках или других местах из которых нельзя _вернуть_ результат

В общем, решение не общее и довольно сложное.
---
# Impossibility of an interactive development

Интерактивная разработка начинает набирать популярность. Практически все более-менее популярные языки имеют в стандартной поставке REPL(отдельно или в составе дебаггера). Современные браузеры и вообще позволяют писать код прямо в них.

Появляются и отдельные IDE нацеленные именно на интерактивную разработку. К примеру Light table, позволяющая в реальном времени следить за результатами вычислений:

Отличная статья о том почему интерактивная разработка - это прекрасно!

---
# Problems


Давайте посмотрим какие коррективы вносят сайд-эффекты в подобную практику. Допустим мы разрабатываем функцию осуществляющую запрос на удаление некотрого юзера - `deleteUser`. Очевидно что мы не сможем запустить эту функцию несколько раз для одного и того же юзера, чтобы проверить ее работу в REPL. Более того для проверки результатов ее работы нам понадобится каждый раз смотреть текущее состояния сервера.

Главное преимущество интерактивной разработки - быстрая ответная реакция от только что написанного кода - в таком случае сводится на нет, тем что нам необходимо постоянно наблюдать состояние окружающего мира и периодически "фиксить" его. Например востанавливать удаленного юзера.

Возможным решением здесь будет REPL интегрированный в тестовый фреймворк - `jest-repl`, `mocha debug repl` с встроенной возможностью устанавливать моки для определенных сайд-эффектов.
---
# Complexity in providing certain properties of program

Тестирование основанное на проверке свойств или генеративное тестирование или property-based тестирование - техника позволяющая описывать свойства какой-то программной сущности(функции к примеру) и проверять ее при помощи генерации входных параметров.

Это очень мощная техника, которая позволяет доказать(с некотрой долей вероятности конечно же) некотрые утверждения о программном коде. Она становится особенно важной в языках без сильной статической системы типов. 

Но крайне сложно определить какое либо свойство для кода с сайд-эффектами - за счет их непредсказуемости.
---
# перерыв

Сайд-эффекты как гремлины ломают все доступные программисту инструменты до которых доберутся: типизация, тесты, интерактивные среды, статические анализаторы в IDE, код-ревью.

Но почему это все действительно важно? Ну да что-то стало сложнее сделать - но программисты привыкли борьбе со сложностью. И в отдельных пунктах я приводил результаты такой борьбы - инструменты которые призваны хоть как-то уменьшить негативное влияние сайд-эффектов.

Проблема в том что сайд-эффекты не только усложняют написание и работу с самим кодом, но и "ломают" два _базовых_ способа разработки ПО. И это уже реальная проблема.
---
# Two kinds of programming
На самом _высоком_ уровне по большому счету существует только два способа разработки. Все остальное либо их комбинации, либо производные.

Давайте расмотрим на простом примере оба способа. Предположим что нам надо разработать систему `printSum`, которая будет выводить на экран сумму какого то списка.
---
# Top-Down
 Определяем спецификацию самого верхнего уровня API - описываем входное и выходное воздействие 

```javascript
printSum(list: Array): PrintedSumToScreenEffect
```
 - Затем определяем спецификации API уровнем ниже которые необходимы чтобы из `Array` получить `PrintedSumToScreenEffect`. Очевидно что нам необходимы две функции.

```javascript
sum(list: Array): number
printToScreen(value: number): PrintedSumToScreenEffect
```

Теперь просто глядя на спецификации мы понимаем что сначала необходимо вызывать от `list` функцию `sum`, а затем от ее результата `printToScreen`.

Теперь осталось придумать как записывать спецификацию для описания входных и выходных данных, в идеале она должна:

 - описывать все возможные входные воздействия и результаты и довольно общим образом - тесты подходят не очень хорошо, так как они описывают отдельные кейсы(точки вместо общего поведения системы).
 - мы должны иметь возможность проверить, что разработанная нами программа соответствует изначальной спецификации - иначе при имплементации, есть большой шанс получить большое расхождение со спецификацией. Диаграммы и прочие способы связанные с ИЗО не дадут нам такой возможности

 Вы наверно уже догадались что лучше все здесь подойдет хорошая система типов
---
# Bottom-Up
Мы можем пойти с другой стороны:

 - Уже по описанию задачи видно что нам надо будет уметь выводить чтото на экран и надо уметь складывать. Мы не будем пытаться определить точные спецификации. Вместо этого просто напишем общие и минимально необходимые функции для этого. Больше всего эти функции будут похожи на отдельные небольшие библиотеки - очень малоспецифичные и очень переиспользуемые единицы. Так как мы еще не знаем что за API нам придется с их помощью строить.

 - Затем строим из этих функций API более высокого уровня.


Для такого итеративного процесса нам необходим инструмент:

 - позволяющий легко экспериментировать с небольшими кусочками кода и иметь возможность быстро запустить отдельные функции на разных входных данных
 - при этом в процессе разработки, нам не так важно зафиксировать некотрый результат и уметь его воспроизводить - скорее всего мы редко будем менять имплементацию уже написанного API. Тесты тут будут скорее мешать низкой скоростью ответной реакции, и своей хрупкостью

Лучше всего для такого стиля разработки подойдет `REPL`. Собственно такой вид разработки и получил распространие в языках с богатой практикой использования `REPL` - `Lisp`, `SmallTalk`.
---
# Two way...
итого у нас есть два способа разработки
сверху вниз и для него мы можем использовать спецификацию при помощи типов

и снизу вверх и для него основным способ разработки является репл
---
# Or no way?

 Однако как мы выяснили без определенных уловок, большая часть систем типов не способны работать с сайд-эффектами и уж точно не могут вывести типы таких эффектов из контекста. Можно конечно было бы заменить типы тестами(что например сделано во всем известном Test Driven Development) - однако как мы уже увидели тесты не очень хорошо для этого подходят из-за своей дискретной природы, и к тому же они тоже страдают от сайд-эффектов.
 
 Таким образом сайд-эффекты ломают первый базовый способ разработки ПО. а со что со вторым?
как мы помним `REPL` теряет свое главное приемущество(быстрый отклик), при разработке кода с сайд-эффектами. Второй фундаментальный способ тоже не выдержал битвы с сайд-эффектами.

Но ведь не весь наш код содержит сайд-эффекты? И может все эти неприятности касаются только тех участков в которых мы их используем? Можно просто старатся использовать поменьше "грязных" функций и побольше "чистых"?
---
# Infects side-effects free code

давайте расмотрим вот такую структуру кода - тут все функции чистые
а теперь давайте сделаем одну из них грязной - добавив кеширование в локалсторадж
и вуаля - все все функции выше тоже стали грязными
Изменив код всего _одной_ функции - мы изменили свойства(в плане тестируемости, надежности, композируемости) для _всего_ стека вызовов.

В некотром смысле мы теряем _контроль_ над своим кодом. Мы не можем гарантировать что никакие свойства для своего кода - так как API на котором основан наш код может _внезапно_ изменить свои свойства и "заразить" наш код.
---
# Two-color language
Программисты заставшие `JS` без `Promise` и `async-await` могут почувствовать, что-то знакомое в описании недостатков сайд-эффектов. Эти же проблемы зачастую упоминались в обсуждении асинхронных функций основанных на коллбэках.

> Асинхронность и сайд-эффекты выглядят довольно связанными проблемами - решив только одну из них вы не избавитесь от всех их недостатков. И наоброт - хорошее решение одной из них может помочь решить другую. В дальнейшем мы увидим что это не случайно и на самом деле эти проблемы являются лишь частными случаями более фундаментальной проблемы отсутсвия общего способа абстракции control-flow программы и выражение его first-class значениями.

Но самое ужасное в таких функциях было то, что они заражали весь код, в котором они использовались. Обычная функция при использования в ней функции с коллбэком переставала возвращать результат через `return` и начинала прокидывать его в коллбэк - и в свою очередь сама становилась "ядом" для использующего ее кода.

Появилась даже метафора двух-цветного языка:
все функции в языке делятся на "красные" и "синие". И чтобы вызвать "красную" функцию в "синей" нам необходимо перекрасить "синюю" функцию в красный цвет.

Происходило это из-за того что подобные асинхронные функции для взаимодействия с кодом не использовали стандартные способы взаимодействия - возврат значения через `return`. Как мы помним сайд-эффекты также возвращают результаты не через `return`, а своим способом(не явно).

Поэтому все тоже самое применимо и к ним:

> Функция с сайд-эффектом внутри, сама становится сайд-эффектом. Следовательно используя такую функцию внутри другой(чистой) мы автоматически преврашаем ее в грязную - она начинает возвращать часть результата неявно. И так далее до самой вершины стека вызовов.
---
# Ice-9 for source code
.center-text[
  <img alt="Cats cradle" src="./img/cats-cradle.jpg" width="50%"/>
]
> \- Ты читал "Колыбель для кошки"?
>
> \- Нет
>
> \- Итак, этом романе мир погибает потому, что во льду обнаружена молекула, которая, при соприкосновении с водой, превращает ее в лед. А поскольку все воды мира связаны - пруд с ручьем, ручей с рекой, река с озером, озеро с океаном - таким образом весь мир замерзает и погибает. И эта молекула называется - "Лед-9"
>
---
# перерыв
---
# Two type of calc

и так мы ввыяснили что в нашем коде есть два типа вычислений - чистые(просто вычисления) и грязные(будем называть их исполнения)

Однако в типичном коде они перемешаны и неотделены друг от друга - давайте отделим
пусть все функции будут возвращать лишь описания эффектов - некотрую структуру данных которая содержит всю необходимую информмацию для выполнения эффекта
а выполнять мы их будем вне функции - теперь мы видим эти два типы кода явно
и мы можем сказать что исполнение сайд-эффектов является так сказать связующим звеном между вычислениями - давайте попробуем представить это ввиду диаграммы
---
# Pure vs Effectful
Простое последовательное вычисление без выполнения эффектов связано между собой без каких либо посредников - вычисленое в первом выражении передается во второе и так далее

При исполнении с эффектами вычисленное в первом выражении проходит через специальный код который исполняет эффекты и передает результат исполнения следующему вычислению
---
# Sync vs Async
Мы уже говорили о том что проблема асинхронности очень похожа на проблему эффектов наличием двух типов вычислений
Давай те расмоотрим синхронный код и асинхронный
Простое последовательное вычисление без асинхронности связано между собой без каких либо посредников - вычисленое в первом выражении передается во второе и так далее

Про асинхронное же исполнение можно сказать что оно связано через функцию "Ожидания" значения которая дожидается результата и передает его в следующее вычисление. То есть помимо самих вычислений отложенных значений их связывает некий слой который дожидается исполнения одного и прокидывает значение в другое вычисление

А есть ли еще какие то похожие проблемы в программировании которые можно разложить на два вида вычислений?
---
# Safe vs Error handling

Давайте вспомним про такую сложную проблему как обработка ошибок
Эта на первый взгляд простая проблема по большому счету не имеет до сих единого принятого решения - даже в жс используются как исключения так и спец хендлеры типо .catch у промисов

Сначала рассмотрим код без обработки ошибок - тут все просто он не отличается от предыдущих
а теперь с обработкой ошибок

Видно что различные вычисления связаны между собой проверкой результата вычисления на ошибочность и в случае если это так то выполнение некотрого хендлера а если не так то передать результат вычисления в следующее вычисление
---
# Not nullable vs nullable
Так же можно вспомнить другую сложную проблему - так называемую проблему на миллион долларов - Null Pointer Exception. 
Эта проблема порождает такой тип вычислений когда перед каждым следующим вычислением мы должны проверить предыдущий результат на нулл и если он нулл то прервать вычисление а если нет то продолжить

То есть таким связующим вычислением звеном является проверка на нулл
---
# Control-flow

Так вот такой вид вычислений который связывает другие вычисления - называется контрол флоу

определение из вики говорит только о порядке однако дело не только в порядке -  но как мы могли заметить дело не совсем в порядке как таковом скорее в том что происходит между вычислениями

В современном языке есть ТЫСЯЧИ контрол флоу примитивов

И обычно обучение программированию начинают именно с них - это считается основами программирования - ветвление цикл итд.

Однако так ли это? по моему глубокому убеждению претендовать на звание основания может только те понятие которые порождают остальные понятия а не являются следствием чего то более глобального и основательного

Мы уже сейчас видим что ветвление и цикл лишь оДни ИЗ примитивов более базового понятия контрол флоу - и современная программа не обходится только ими

Нам нужно найти действительные основания прогрмммирования и для этого давайте окунемся в историю и посмотрим с чего все начиналось и как текла научная и инженерная мысль в области программирования
---
# Перерыв
---
# GOTO
Самое интересное что когда то очень давно когда не было никаких ветвлений(с оговорками) и циклов - что уже говорит о том что они не могут являтся основаниями программирования - ведь до какого то момента программирование прекрасно без низ обходилось

изначально главным контрол флоу примтивом был переход на метку - гоуту и условный переход на метку

чем то это может напомнить операторы бреак и континуе для циклов - мы ставили в производном месте кода метку и потом можгли из любого места перейти к ней

объясняю на примере

давайте посмотрим как работает условный переход на каком то более живом примере - например на примере обработки ошибок
---
# Example: error handling

слева код с обработкой ошибок без использования эксепшенов
такой код зачастую встречается и сегодня - а некотрые языки такие как го или свифт не имеют механизма эксепшенов и поэтому там любая обработка ошибок выглядит именно так.

Писать такой код довольно неудобно - у нас образуется лесенка из ветвлений которая замусоривает логику самих вычислений.

Как решали эту проблему во временя гоуту?
Весь код связанный с обработкой ошибок выносится в специальную функцию которая позволяет при возникновении ошибки выпрыгнуть из текущего потока вычислений и обработать ошибку

Главной управляющей конструкцией здесь является ветвление и гоуту а точнее их комбинация
---
# Don't forget where you came from
Собственно комбинация гоуту и ветвления - так сказать условный гоуту - это проматерь всех управляющих кострукций - все остальные управляющие конструкции можно так или иначе выразить через нее - и так и делали до появления структурного программирования.
Дававйте посмотрим как реализовать цикл вайл при помощи условного прыжка - показываю на код

Ничего в этом мире не появляется ниоткуда - программирование при помощи переходов(прыжков) от одного состояния к другому появилось намного раньше чем появились сами компьютеры

в 36 году алан тьюринг придумал свою вычислительную систему в которой моожно выразить любой алгоритм любое вычисление

В состав машины Тьюринга входит неограниченная в обе стороны лента, разделённая на ячейки, и управляющее устройство (также называется головкой записи-чтения (ГЗЧ)), способное находиться в одном из множества состояний. Число возможных состояний управляющего устройства конечно и точно задано.
Управляющее устройство может перемещаться влево и вправо по ленте, читать и записывать в ячейки символы некоторого конечного алфавита. Выделяется особый пустой символ, заполняющий все клетки ленты, кроме тех из них (конечного числа), на которых записаны входные данные.
Управляющее устройство работает согласно правилам перехода, которые представляют алгоритм, реализуемый данной машиной Тьюринга. Каждое правило перехода предписывает машине, в зависимости от текущего состояния и наблюдаемого в текущей клетке символа, записать в эту клетку новый символ, перейти в новое состояние и переместиться на одну клетку влево или вправо. Некоторые состояния машины Тьюринга могут быть помечены как терминальные, и переход в любое из них означает конец работы, остановку алгоритма.

Посути правила перехода это и есть условные прыжки а записи значений это вычисления
---
# All is need you is...
То есть таким образом мы абсолютно точно уверены что любое вычисление любой алгоритм можно представить имея всего две сущности

- вычисление
- условный прыжок

давайте подробнее расмотрим каждую из них и попробуем выъявить существенные качество того и другого - то есть же отличает их друг от друга и почему одно не может существовать без другого - оно оказывается неполным для описания алгоримта

расматриваем вычисление - как будет вычислятся такое выржение?


Расматриваем условный переход - как будет вычислятся такое выражение?
Давайте подумаем почему условный прыжок нельзя свести к вычислению
Вся разница посути в в порядке вычисления
Если считать что гоуту и само условие это аргументы некотрого вычисления иф то можно увидеть что порядок вычисления этого иф сильно отличается от вычисления эдд

Рассказываю про разницу в порядке

Давайте расмотрим более деталльно такой порядок вычислений -  когда вычисляется сначала сама функция и только потом если необходимо ее аргументы
---
# New World Order

Давайте представим что вообще все в нашем коде вычисляется именно так
как это выглядит На примере add

расказываю

с таким порядком вычислений мы легко сможем реализовать условный переход как обычную функцию

расказываю - сначала она вычислит условие и потом только если надо вычислит переход
---
# In your code
Многие наверно сейчас находятся в замешательстве - какой то странный этот порядок вычислений
Однако мы часто используем подобный порядок вычислений в своем коде
Давайте расмотрим частно встречающуюся конструкцию - логическую и

Расмотрим левое выражение - его часто использую когда неуверены существуют ли в обьекте вложенные свойства - то есть для безопастного доступа к глубоким свойствам обьекта

Давайте подумаем почему эту запись нельзя заменить на запись справа в виде вызова обычных функций энд - это функция которая делает туже операцию что и &&

Однако этот код не эквивалентен

в первом случае мы сначала начнем вычислять саму операцию - логическое и - которая по мере необходимости будет вычислять аргументы - то есть воспользуемся уже знакомым нам обратным порядком вычислений. И когда x.obj окажется ложным - мы не будем дальше ничего вычислять - так как в этом просто нет смысла - выражение всеравно будет ложным

Во втором случае мы сначала вычислим все аргументы и получим ошибку невозможности вызвать свойство проп от андефанед - то есть в данном случае порядок вычислений будет привычный нам прямой

Как мы помним работа с опциональными значениями один из примеров контрол-флоу и тут нам очень хорошо помогает обнаруженный нами обратный порядок вычислений
---
# Reverse effects

А может ли он нам помчь с работой с эффектами?

ДАвайте попробуем
Есть у нас вот такие вычисления - описываю

если мы начнем вычислять такое выражение в прямом порядке то ничего не получится - будет ошибка
а давайте попробуем пойти не снизу а сверху - в обратном порядке

Видим запись в файл - понимаем что ей нужен результат вычисдения фио
а ему нужна результат запроса - вычисляем requestUser - видим флаг isEff - то есть что это эффект и его нужно выполнить - выполняем и получаем результат

далее от этого результата вычисляем фио
а фио уже используем чтоб получить результат записи и выполнить ее
таким образом обратный порядок помогает нам вычстроить всю цепочку вычислений и если у нас есть возможность вклинится в этот процесс(выяислений) то мы можем выполнять различные операции -например выполнять эффекты
---
# This is the norm
Normal order a.k.a call-by-name(call-by-need) a.k.a lazy evaluation

Without it all our languages is not turing-complete

Theorem: all calculations can be calculated with normal order

First "programming language":

- 1936 Alonzo Church - Lambda calculus - normal order
- 1936 Alan Turing - Turing machine - applicative order

First computer:
- 1944 - Von Neumann architecture(inspired Turing machine)

.right-column-50[
With normal order:

**all is calculation**
]
.left-column-50[
With applicative order:

**all is calculation+control-flow**
]
---
# Control-flow as contituation
Continuation-passing style:

Effects:
```javascript
requestUser(user => {
  writeToFile(user.fio,
    res => { ... }
  )
})
```

Errors:
```javascript
doWithErrors(res => {
  doWithErrors2(
    res,
    res2 => { ... },
    handleErr
  )
},handleErr)
```
---
# Introduce call/cc
.left-column-50[
```javascript
var a = 3;
var b = a
var c = b + 1 // 4
```
]
.right-column-50[
```javascript
var a = 3;
var b = callcc(cont => {
  cont(a)  
});
var c = b + 1 // 4
```
```javascript
var r;
var a = 3;
var b = callcc(cont => {
  r = cont;  
});
var c = b + 1
r(a) // 4
```
]
---
# Exceptions
```javascript
var cont;
function throw (err) {
  cont(err);
}
function try(program, handleErr) {
  var res = callcc(c => {
    cont = c;
    program()
  })
  handleErr(res)
}

try(
  () => {
    var a = doWithErrors() // throw new Error()
    ...
  },
  err => { ... }
)
```
[Writing exceptions by contituations](http://courses.cs.washington.edu/courses/cse341/04wi/lectures/15-scheme-continuations.html)
---
# Algebraic effects
```javascript
var cont;
function perform (effect) {
  callcc(currCont => {
    var res = cont(err);
    currCont(res)  
  })  
}
function run(program, handleEffect) {
  var res = callcc(c => {
    cont = c;
    program()
  })
  return handleEffect(res)
}

run(
  () => {
    var user = perform(requestUser())
    var fio = user.fio
    var res = perform(writeToFile(fio))
  },
  eff => runEffect(eff)
)
```
[Algebraic effects: esdiscuss](https://esdiscuss.org/topic/one-shot-delimited-continuations-with-effect-handlers)
---
# Continuation as precursor

- exceptions
- algebraic effects with handlers
- generators
- fibers
- coroutines
---
# Control-flow as High Order Calculation
```javascript
writeToFile(requestUser().fio)
```
Control-flow is a glue for calculations

From execution to calculation a.k.a thunk:

`requestUser() -> () => requestUser()`

Thunk is lazy!

.left-column-50[
```javascript
// calculation
var ioAction = composeWithEffects(
  () => requestUser(),
  x => x.fio,
  fio => writeToFile(fio)
)

// execution
run(ioAction)
```
]
.right-column-50[
```javascript
ioAction = {
  calc: fio => writeToFile(fio),
  args: [
    {
      calc: x => x.fio,
      args: {
        calc: () => requestUser()
      }
    }
  ]
}
```
]
---
# Lets make great interface
.left-column-50[
```javascript
function IO(fn) {
  this = {
    calc: fn,
    args: []
  };
}
IO.prototype.then = fn => {
  this = {
    calc: fn,
    args: [
      this
    ]
  }
}
```
]
.right-column-50[
```javascript
var ioAction = new IO(requestUser)
  .then(x => x.fio)
  .then(fio =>
    new IO(() => writeToFile(fio))
  )

run(ioAction)
```
```javascript
ioAction = {
  calc: new IO(() => writeToFile(fio)),
  args: [
    {
      calc: x => x.fio,
      args: {
        calc: new IO(requestUser)
      }
    }
  ]
}
```
]
---
# Not only effects...
```javascript
var x = {}
x && x.obj && x.obj.prop
```

.left-column-50[
```javascript
function Option(value) {
  this = value;
}
Option.prototype.then = fn => {
  this = isNil(this) ?
    this :
    fn(this)
}
```
]

.right-column-50[
```javascript
var x = {};
var val = new Option(x)
  .then(val => val.obj)
  .then(obj => val.obj.prop)
```
]
---
# Representing monads

 - `of`, `pure`, `unit` - constructor. *How wrap value to monad?*
 - `flatMap`, `bind`, `return` - applyer. *How unwrap value from monad?*

Monad laws:
 - Left identity: `flatMap(f, of(x)) === f(x)`
 - Right identity: `flatMap(of, x)`
 - Associativity: `flatMap(g, flatMap(f, x)) === flatMap(x => g(f(x)), x)`

[Dont break laws!](https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/)

**Beware of Haskell Police!**

---
# Monads everywhere!

- `Promise` a.k.a `Task` a.k.a `Future`
- `Optional` a.k.a `Option` a.k.a `Maybe`
- `List`
- `Either` a.k.a `Try` a.k.a `Error`
- `Observable`
---
# Two way?

Monads and Contituations is isomorphic and equal by power

[Representing Monads](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.8213&rep=rep1&type=pdf)

This is just representations of **control-flow**

Control-flow is originated by incompleteness strict(applicative) evaluation

[Lazy Evaluation and Delimited Control](http://www.osl.iu.edu/publications/prints/2009/garcia09popl-lazy.pdf)
---
# A journey of a thousand miles starts with a single step
![Scheme of all](./img/origins.svg)
---
# Plato's cave

<img alt="Plato cave" src="./img/platoCave.jpg" width="100%" />
---
# Third way???

Message passing as foundation of OOP:
 - 1967 - [Simula](https://en.wikipedia.org/wiki/Simula)
 - 1970 - [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk)

Message passing as foundation concurrent computation:
 - 1973 - [Actor model](https://en.wikipedia.org/wiki/Actor_model)
 - 1977 - [Communicating sequential processes](https://en.wikipedia.org/wiki/Communicating_sequential_processes)

All modern frontend framework based on message-passing primitive:
 - `store` in `flux`, `redux`, `ngrx/store`
 - `computed` in `mobx`, `vue`, `ember`
 - `EventEmitter` in angular2
 - `subscriptions` and `Cmd` in Elm

All modern backend framework based on message-passing primitive:
 - `actor` in `Akka`, `Erlang`, `Elixir`
 - `channels` in Go
 - `ReactiveStreams` in Spring